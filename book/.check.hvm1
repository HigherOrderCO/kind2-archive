// Types
// -----

//data Maybe
  //= (Some value)
  //| None

//data Bool
  //= False
  //| True

//data Pair
  //= (Pair fst snd)

//data Term
  //= (All nam inp bod)
  //| (Lam nam bod)
  //| (App fun arg)
  //| (Ann val typ)
  //| (Slf nam typ bod)
  //| (Ins val)
  //| (Ref nam sub val)
  //| (Let nam val bod)
  //| (Set)
  //| (U60)
  //| (Num val)
  //| (Op2 opr fst snd)
  //| (Mat nam x z s p)
  //| (Txt txt)
  //| (Hol nam ctx val)
  //| (Var nam idx) 
  //| (Src src val)

// Prelude
// -------

(U60.seq 0 cont) = (cont 0)
(U60.seq n cont) = (cont n)

(String.seq (String.cons x xs) cont) = (U60.seq x λx(String.seq xs λxs(cont (String.cons x xs))))
(String.seq String.nil         cont) = (cont String.nil)

(Print dep []  value) = value
(Print dep msg value) = (String.seq (String.join msg) λstr(HVM.log str value))
//(Print dep []  value) = value
//(Print dep msg value) = (If (> dep 10) 1 (HVM.print (String.join msg) value))

(NewLine) = (String.cons 10 String.nil)
(Quote)   = (String.cons 34 String.nil)

(And True  b) = b
(And False b) = False

(Or True  b) = True
(Or False b) = b

(If 0 t f) = f
(If n t f) = t

(When None       some none) = none
(When (Some val) some none) = (some val)

(U60.show n)                = (U60.show.go n String.nil)
(U60.show.go n res)         = (U60.show.go.match (< n 10) n res)
(U60.show.go.match 0 n res) = (U60.show.go (/ n 10) (String.cons (+ '0' (% n 10)) res))
(U60.show.go.match i n res) = (String.cons (+ '0' n) res)

(U60.name n)    = (U60.name.go (+ n 1))
(U60.name.go 0) = ""
(U60.name.go n) = (String.cons (+ 97 (% (- n 1) 26)) (U60.name.go (/ (- n 1) 26)))

(Same String.nil         String.nil)         = 1
(Same String.nil         (String.cons y ys)) = 0
(Same (String.cons x xs) String.nil)         = 0
(Same (String.cons x xs) (String.cons y ys)) = (& (== x y) (Same xs ys))

(Find name List.nil)                        = None
(Find name (List.cons (Pair nam val) tail)) = (If (Same nam name) (Some val) (Find name tail))

(List.map f (List.cons x xs)) = (List.cons (f x) (List.map f xs))
(List.map f List.nil)         = List.nil

(String.concat String.nil         ys) = ys
(String.concat (String.cons x xs) ys) = (String.cons x (String.concat xs ys))

(String.join List.nil)         = ""
(String.join (List.cons x xs)) = (String.concat x (String.join xs))

(Pair.fst (Pair fst snd)) = fst
(Pair.snd (Pair fst snd)) = snd

(Pair.get (Pair fst snd) fun) = (fun fst snd)

(Maybe.match (Some value) some none) = (some value)
(Maybe.match None         some none) = none

(Maybe.pure x) = (Some x)
(Maybe.bind a b) = (Maybe.match a λvalue(b value) None)

// Converts an U60 to a bitstring
(U60.to_bits 0) = E
(U60.to_bits 1) = (I E)
(U60.to_bits n) = (If (== (% n 2) 0) (O (U60.to_bits (/ n 2))) (I (U60.to_bits (/ n 2))))

(String.color RESET)      = (String.cons 27 "[0m")
(String.color BRIGHT)     = (String.cons 27 "[1m")
(String.color DIM)        = (String.cons 27 "[2m")
(String.color UNDERSCORE) = (String.cons 27 "[4m")
(String.color BLINK)      = (String.cons 27 "[5m")
(String.color REVERSE)    = (String.cons 27 "[7m")
(String.color HIDDEN)     = (String.cons 27 "[8m")
(String.color BLACK)      = (String.cons 27 "[30m")
(String.color RED)        = (String.cons 27 "[31m")
(String.color GREEN)      = (String.cons 27 "[32m")
(String.color YELLOW)     = (String.cons 27 "[33m")
(String.color BLUE)       = (String.cons 27 "[34m")
(String.color MAGENTA)    = (String.cons 27 "[35m")
(String.color CYAN)       = (String.cons 27 "[36m")
(String.color WHITE)      = (String.cons 27 "[37m")
(String.color GRAY)       = (String.cons 27 "[90m")
(String.color BG_BLACK)   = (String.cons 27 "[40m")
(String.color BG_RED)     = (String.cons 27 "[41m")
(String.color BG_GREEN)   = (String.cons 27 "[42m")
(String.color BG_YELLOW)  = (String.cons 27 "[43m")
(String.color BG_BLUE)    = (String.cons 27 "[44m")
(String.color BG_MAGENTA) = (String.cons 27 "[45m")
(String.color BG_CYAN)    = (String.cons 27 "[46m")
(String.color BG_WHITE)   = (String.cons 27 "[47m")
(String.color BG_GRAY)    = (String.cons 27 "[100m")
(String.color x)          = "?"

// BitsMap
// -------

(Map.new) = List.nil

(Map.has eq k (List.cons (Pair key val) map)) = (If (eq key k) 1 (Map.has eq k map))
(Map.has eq k List.nil)                       = 0

(Map.ins eq k v (List.cons (Pair key val) map)) = ((If (eq key k) λmap(None) λmap(Maybe.bind (Map.ins eq k v map) λmap(Some (List.cons (Pair key val) map)))) map)
(Map.ins eq k v List.nil)                       = (Some (List.cons (Pair k v) List.nil))

(Map.set eq k v (List.cons (Pair key val) map)) = ((If (eq key k) λmap(List.cons (Pair k v) map) λmap(List.cons (Pair key val) (Map.set eq k v map))) map)
(Map.set eq k v List.nil)                       = (List.cons (Pair k v) List.nil)

(Map.get eq k (List.cons (Pair key val) map)) = (If (eq key k) (Some val) (Map.get eq k map))
(Map.get eq k List.nil)                       = None

// Holes
// -----

(Subst (List.cons (Pair nam None)     subs) val) = (Subst subs (val None))
(Subst (List.cons (Pair nam (Some x)) subs) val) = (Subst subs (val (Some x)))
(Subst List.nil                             val) = val

// Evaluation
// ----------

(Reduce lv (App fun arg))     = (Reduce.app lv (Reduce lv fun) arg)
(Reduce lv (Ann val typ))     = (Reduce lv val)
(Reduce lv (Ins val))         = (Reduce lv val)
(Reduce lv (Ref nam sub val)) = (Reduce.ref lv nam sub (Reduce lv val))
(Reduce lv (Let nam val bod)) = (Reduce lv (bod val))
(Reduce lv (Op2 opr fst snd)) = (Reduce.op2 lv opr (Reduce lv fst) (Reduce lv snd))
(Reduce lv (Mat nam x z s p)) = (Reduce.mat lv nam (Reduce lv x) z s p)
(Reduce lv (Hol nam ctx val)) = (Reduce.hol lv nam ctx val)
(Reduce lv (Txt txt))         = (Reduce.txt lv txt)
(Reduce lv (Src src val))     = (Reduce lv val)
(Reduce lv val)               = val

//(Reduce.app lv (Ref nam sub val) arg) = (Reduce.app lv val arg) // FIXME: should this be here? (no.)
(Reduce.app lv (Lam nam bod)     arg) = (Reduce lv (bod (Reduce 0 arg)))
(Reduce.app lv fun               arg) = (App fun arg)

(Reduce.op2 lv ADD (Num fst) (Num snd)) = (Num (+ fst snd))
(Reduce.op2 lv SUB (Num fst) (Num snd)) = (Num (- fst snd))
(Reduce.op2 lv MUL (Num fst) (Num snd)) = (Num (* fst snd))
(Reduce.op2 lv DIV (Num fst) (Num snd)) = (Num (/ fst snd))
(Reduce.op2 lv MOD (Num fst) (Num snd)) = (Num (% fst snd))
(Reduce.op2 lv EQ  (Num fst) (Num snd)) = (Num (== fst snd))
(Reduce.op2 lv NE  (Num fst) (Num snd)) = (Num (!= fst snd))
(Reduce.op2 lv LT  (Num fst) (Num snd)) = (Num (< fst snd))
(Reduce.op2 lv GT  (Num fst) (Num snd)) = (Num (> fst snd))
(Reduce.op2 lv LTE (Num fst) (Num snd)) = (Num (<= fst snd))
(Reduce.op2 lv GTE (Num fst) (Num snd)) = (Num (>= fst snd))
(Reduce.op2 lv AND (Num fst) (Num snd)) = (Num (& fst snd))
(Reduce.op2 lv OR  (Num fst) (Num snd)) = (Num (| fst snd))
(Reduce.op2 lv XOR (Num fst) (Num snd)) = (Num (^ fst snd))
(Reduce.op2 lv LSH (Num fst) (Num snd)) = (Num (<< fst snd))
(Reduce.op2 lv RSH (Num fst) (Num snd)) = (Num (>> fst snd))
(Reduce.op2 lv opr fst snd)             = (Op2 opr fst snd)

(Reduce.mat lv nam (Num 0)             z s p) = (Reduce lv z)
(Reduce.mat lv nam (Num n)             z s p) = (Reduce lv (s (Num (- n 1))))
(Reduce.mat lv nam (Op2 ADD (Num 1) k) z s p) = (Reduce lv (s k))
(Reduce.mat lv nam val                 z s p) = (Mat nam val z s p)

(Reduce.ref 1  nam sub val) = (Reduce 1 (Subst sub val))
(Reduce.ref lv nam sub val) = (Ref nam sub val)

(Reduce.hol lv nam ctx None)     = (Hol nam ctx None)
(Reduce.hol lv nam ctx (Some x)) = (Reduce lv x)

(Reduce.txt lv (String.cons x xs)) = (Reduce lv (App (App Book.String.cons (Num x)) (Txt xs)))
(Reduce.txt lv String.nil)         = (Reduce lv Book.String.nil)
(Reduce.txt lv val)                = (Txt val)

(Normal lv term dep) = (Normal.term lv (Reduce lv term) dep)

(Normal.term lv (All nam inp bod) dep) = (All nam (Normal lv inp dep) λx(Normal lv (bod (Var nam dep)) (+ dep 1)))
(Normal.term lv (Lam nam bod)     dep) = (Lam nam λx(Normal lv (bod (Var nam dep)) (+ 1 dep)))
(Normal.term lv (App fun arg)     dep) = (App (Normal lv fun dep) (Normal lv arg dep))
(Normal.term lv (Ann val typ)     dep) = (Ann (Normal lv val dep) (Normal lv typ dep))
(Normal.term lv (Slf nam typ bod) dep) = (Slf nam typ λx(Normal lv (bod (Var nam dep)) (+ 1 dep)))
(Normal.term lv (Ins val)         dep) = (Ins (Normal lv val dep))
(Normal.term lv (Ref nam sub val) dep) = (Ref nam sub (Normal lv val dep))
(Normal.term lv (Let nam val bod) dep) = (Let nam (Normal lv val dep) λx(Normal lv (bod (Var nam dep)) (+ 1 dep)))
(Normal.term lv (Hol nam ctx val) dep) = (Hol nam ctx (Maybe.match val λx(Some (Normal lv x dep)) None))
(Normal.term lv Set               dep) = Set
(Normal.term lv U60               dep) = U60
(Normal.term lv (Num val)         dep) = (Num val)
(Normal.term lv (Op2 opr fst snd) dep) = (Op2 opr (Normal.term lv fst dep) (Normal.term lv snd dep))
(Normal.term lv (Mat nam x z s p) dep) = (Mat nam (Normal lv x dep) (Normal lv z dep) λk(Normal lv (s (Var (String.concat nam "-1") dep)) dep) λk(Normal lv (p (Var nam dep)) dep))
(Normal.term lv (Txt val)         dep) = (Txt val)
(Normal.term lv (Var nam idx)     dep) = (Var nam idx)
(Normal.term lv (Src src val)     dep) = (Src src (Normal lv val dep))

// Checker
// -------

// type Result A = (Done Logs A) | (Fail Logs String)
// type Checker A = Logs -> (Result A)

(Result.match (Done logs value) done fail) = (done logs value)
(Result.match (Fail logs error) done fail) = (fail logs error)     

//(State.get fill got) = (got fill logs)
//(State.new)          = []

(Checker.bind a b)  = λlogs (Result.match (a logs) λlogsλvalue((b value) logs) λlogsλerror(Fail logs error))
(Checker.pure a)    = λlogs (Done logs a)
(Checker.fail e)    = λlogs (Fail logs e)
(Checker.run chk)   = (chk [])
(Checker.log msg)   = λlogs (Done (List.cons msg logs) 1)
(Checker.save)      = λlogs (Done logs logs)
(Checker.load logs) = λeras (Done logs 0)

// Equality
// --------

// The conversion checkers works as follows:
//   1. If the two sides are structurally identical, they're equal.
//   2. Otherwise, reduce both sides.
//   3. If the two sides are structurally identical, they're equal.
//   4. Otherwise, recurse on both sides and check if all fields are equal.
// This algorithm will return true when both sides reduce to the same normal
// form, but it will halt early if both sides become identical at any point
// during the reduction, allowing checking recursive terms. This is enough to
// cover any interesting term. Note we need to be careful with self-types, which
// must be "un-unrolled" to avoid loops. Read `docs/equality.md` for more info.

// Checks if two term are equal
(Equal a b dep) = 
  //(Print dep ["Equal: " NewLine "- " (Show a dep) NewLine "- " (Show b dep)]
  (Compare a b dep
  let a = (Reduce 1 a)
  let b = (Reduce 1 b)
  (Compare a b dep
  (Similar a b dep)))

// Checks if two terms are structurally identical
// If yes, returns 1 (identical) or 2 (suspended)
// If not, undoes effects (logs, unifications, etc.)
(Compare a b dep else) =
  (Checker.bind (Checker.save) λlogs
  (Checker.bind (Identical a b dep) λequal
  (If equal
    (Checker.pure equal)
    (Checker.bind (Checker.load logs) λx (else)))))

// Checks if all components of a term are equal
(Similar (All a.nam a.inp a.bod) (All b.nam b.inp b.bod) dep) =
  (Checker.bind (Equal a.inp b.inp dep) λe.inp
  (Checker.bind (Equal (a.bod (Var a.nam dep)) (b.bod (Var b.nam dep)) (+ 1 dep)) λe.bod
  (Checker.pure (& e.inp e.bod))))
(Similar (Lam a.nam a.bod) (Lam b.nam b.bod) dep) =
  (Equal (a.bod (Var a.nam dep)) (b.bod (Var b.nam dep)) (+ 1 dep))
(Similar (App a.fun a.arg) (App b.fun b.arg) dep) =
  (Checker.bind (Equal a.fun b.fun dep) λe.fun
  (Checker.bind (Equal a.arg b.arg dep) λe.arg
  (Checker.pure (& e.fun e.arg))))
(Similar (Slf a.nam a.typ a.bod) (Slf b.nam b.typ b.bod) dep) =
  (Similar (Reduce 0 a.typ) (Reduce 0 b.typ) dep) // <- must call Similar, NOT Equal
(Similar (Hol a.nam a.ctx a.val) (Hol b.nam b.ctx a.val) dep) =
  (Checker.pure (Same a.nam b.nam))
(Similar (Op2 a.opr a.fst a.snd) (Op2 b.opr b.fst b.snd) dep) =
  (Checker.bind (Equal a.fst b.fst dep) λe.fst
  (Checker.bind (Equal a.snd b.snd dep) λe.snd
  (Checker.pure (Same e.fst e.snd))))
(Similar (Mat a.nam a.x a.z a.s a.p) (Mat b.nam b.x b.z b.s b.p) dep) =
  (Checker.bind (Equal a.x b.x dep) λe.x
  (Checker.bind (Equal a.z b.z dep) λe.z
  (Checker.bind (Equal (a.s (Var (String.concat a.nam "-1") dep)) (b.s (Var (String.concat b.nam "-1") dep)) dep) λe.s
  (Checker.bind (Equal (a.p (Var a.nam dep)) (b.p (Var b.nam dep)) dep) λe.p
  (& e.x (& e.z (& e.s e.p)))))))
(Similar a b dep) =
  (Checker.pure 0)

// Checks if two terms are structurally identical
(Identical a b dep) =
  //(Print dep ["Identical?" NewLine "- " (Show a dep) NewLine "- " (Show b dep)]
  (Unify.try b a dep
  (Unify.try a b dep
  (Identical.go a b dep)))

(Identical.go (All a.nam a.inp a.bod) (All b.nam b.inp b.bod) dep) =
  (Checker.bind (Identical a.inp b.inp dep) λi.inp
  (Checker.bind (Identical (a.bod (Var a.nam dep)) (b.bod (Var b.nam dep)) (+ 1 dep)) λi.bod
  (Checker.pure (& i.inp i.bod))))
(Identical.go (Lam a.nam a.bod) (Lam b.nam b.bod) dep) =
  (Identical (a.bod (Var a.nam dep)) (b.bod (Var b.nam dep)) (+ 1 dep))
(Identical.go (App a.fun a.arg) (App b.fun b.arg) dep) =
  (Checker.bind (Identical a.fun b.fun dep) λi.fun
  (Checker.bind (Identical a.arg b.arg dep) λi.arg
  (Checker.pure (& i.fun i.arg))))
(Identical.go (Slf a.nam a.typ a.bod) (Slf b.nam b.typ b.bod) dep) =
  (Identical a.typ b.typ dep)
(Identical.go (Ins a.val) b dep) =
  (Identical a.val b dep)
(Identical.go a (Ins b.val) dep) =
  (Identical a b.val dep)
(Identical.go (Let a.nam a.val a.bod) b dep) =
  (Identical (a.bod a.val) b dep)
(Identical.go a (Let b.nam b.val b.bod) dep) =
  (Identical a (b.bod b.val) dep)
(Identical.go Set Set dep) =
  (Checker.pure 1)
(Identical.go (Ann a.val a.typ) b dep) =
  (Identical a.val b dep)
(Identical.go a (Ann b.val b.typ) dep) =
  (Identical a b.val dep)
(Identical.go (Hol a.nam a.ctx (Some a.val)) b dep) =
  (Identical a.val b dep)
(Identical.go a (Hol b.nam b.ctx (Some b.val)) dep) =
  (Identical a b.val dep)
(Identical.go (Hol a.nam a.ctx a.val) (Hol b.nam b.ctx a.val) dep) =
  (Checker.pure (Same a.nam b.nam))
(Identical.go U60 U60 dep) =
  (Checker.pure 1)
(Identical.go (Num a.val) (Num b.val) dep) =
  (Checker.pure (== a.val b.val))
(Identical.go (Op2 a.opr a.fst a.snd) (Op2 b.opr b.fst b.snd) dep) =
  (Checker.bind (Identical a.fst b.fst dep) λi.fst
  (Checker.bind (Identical a.snd b.snd dep) λi.snd
  (Checker.pure (& i.fst i.snd))))
(Identical.go (Mat a.nam a.x a.z a.s a.p) (Mat b.nam b.x b.z b.s b.p) dep) =
  (Checker.bind (Identical a.x b.x dep) λi.x
  (Checker.bind (Identical a.z b.z dep) λi.z
  (Checker.bind (Identical (a.s (Var (String.concat a.nam "-1") dep)) (b.s (Var (String.concat b.nam "-1") dep)) dep) λi.s
  (Checker.bind (Identical (a.p (Var a.nam dep)) (b.p (Var b.nam dep)) dep) λi.p
  (& i.x (& i.z (& i.s i.p)))))))
(Identical.go (Txt a.txt) (Txt b.txt) dep) =
  (Checker.pure (Same a.txt b.txt))
(Identical.go (Src a.src a.val) b dep) =
  (Identical a.val b dep)
(Identical.go a (Src b.src b.val) dep) =
  (Identical a b.val dep)
(Identical.go (Ref a.nam a.sub a.val) (Ref b.nam b.sub b.val) dep) =
  (Checker.pure (Same a.nam b.nam))
(Identical.go (Var a.nam a.idx) (Var b.nam b.idx) dep) =
  (Checker.pure (== a.idx b.idx))
(Identical.go a b dep) =
  (Checker.pure 0)

// Unification
// -----------

// The unification algorithm is a simple pattern unifier, based on smalltt:
// > https://github.com/AndrasKovacs/elaboration-zoo/blob/master/03-holes/Main.hs
// The 'Unify.try' fn will attempt to match the following pattern:
//   (?A x y z ...) = B
// Where:
//   1. The LHS spine, `x y z ...`, consists of distinct variables.
//   2. Every free var of the RHS, `B`, occurs in the spine.
//   3. The LHS hole, `?A`, doesn't occur in the RHS, `B`.
// If it is successful, it outputs the following substitution:
//   ?A = λx λy λz ... B
// The `Unify.pat` fn will just recurse on the LHS apps, reaching the hole.
// The `Unify.sub` fn will try to generate the subst, respecting the criteria.
// The `Unify.rec` fn checks the 3rd condition, preventing recursive substs.

// Unify.try : Term -> Term -> U60 -> (Checker U60) -> (Checker U60)
(Unify.try a b dep else) =
  (Maybe.match (Unify.pat a b dep Map.new)
    λkv(Pair.get kv λkλv
      (Checker.bind (Checker.log (Fill k v dep)) λx
      (Checker.pure 1)))
    (If (Unify.skp a)
      (Checker.pure 1)
      (else)))

// Unify.skp : Term -> Bool
(Unify.skp (App fun arg))      = (Unify.skp fun)
(Unify.skp (Ann val typ))      = (Unify.skp val)
(Unify.skp (Ins val))          = (Unify.skp val)
(Unify.skp (Src src val))      = (Unify.skp val)
(Unify.skp (Hol nam ctx None)) = 1
(Unify.skp other)              = 0

// Unify.pat : Term -> Term -> U60 -> (Map U60 Term) -> (Maybe (Pair nam Term))
(Unify.pat (App fun (Var nam idx)) b dep ctx) =
  (Maybe.bind (Map.ins λaλb(== a b) idx $x ctx) λctx
  (Maybe.bind (Unify.pat fun b dep ctx) λkv 
  (Pair.get kv λkλv(Maybe.pure (Pair k (Lam nam λ$x(v)))))))
(Unify.pat (Hol nam ctx None) b dep ctx) =
  (Maybe.bind (Unify.sub b dep nam ctx) λneo
  (Maybe.pure (Pair nam neo)))
(Unify.pat (App fun (Ann val _))          b dep ctx) = (Unify.pat (App fun val) b dep ctx)
(Unify.pat (App fun (Ins val))            b dep ctx) = (Unify.pat (App fun val) b dep ctx)
(Unify.pat (App fun (Src _ val))          b dep ctx) = (Unify.pat (App fun val) b dep ctx)
(Unify.pat (App fun (Hol _ _ (Some val))) b dep ctx) = (Unify.pat (App fun val) b dep ctx)
(Unify.pat (Ann val typ)                  b dep ctx) = (Unify.pat val b dep ctx)
(Unify.pat (Ins val)                      b dep ctx) = (Unify.pat val b dep ctx)
(Unify.pat (Src src val)                  b dep ctx) = (Unify.pat val b dep ctx)
(Unify.pat (Hol nam ctx (Some val))       b dep ctx) = (Unify.pat val b dep ctx)
(Unify.pat other                          b dep ctx) = None

// Unify.sub : Term -> U60 -> String -> (Map U60 Term) -> (Maybe Term)
(Unify.sub (All nam inp bod) dep hol ctx) =
  (Maybe.bind (Unify.sub inp dep hol ctx) λinp
  (Maybe.bind (Unify.sub (bod (Var nam dep)) (+ dep 1) hol ctx) λbod
  (Maybe.pure (All nam inp λ_(bod)))))
(Unify.sub (Lam nam bod) dep hol ctx) =
  (Maybe.bind (Unify.sub (bod (Var nam dep)) (+ 1 dep) hol ctx) λbod
  (Maybe.pure (Lam nam λ_(bod))))
(Unify.sub (App fun arg) dep hol ctx) =
  (Maybe.bind (Unify.sub fun dep hol ctx) λfun
  (Maybe.bind (Unify.sub arg dep hol ctx) λarg
  (Maybe.pure (App fun arg))))
(Unify.sub (Ann val typ) dep hol ctx) =
  (Maybe.bind (Unify.sub val dep hol ctx) λval
  (Maybe.bind (Unify.sub typ dep hol ctx) λtyp
  (Maybe.pure (Ann val typ))))
(Unify.sub (Slf nam typ bod) dep hol ctx) =
  (Unify.sub typ dep hol ctx)
(Unify.sub (Ins val) dep hol ctx) =
  (Maybe.bind (Unify.sub val dep hol ctx) λval
  (Maybe.pure (Ins val)))
(Unify.sub (Ref nam sub val) dep hol ctx) =
  (Maybe.pure (Ref nam sub val))
(Unify.sub (Let nam val bod) dep hol ctx) =
  (Maybe.bind (Unify.sub val dep hol ctx) λval
  (Maybe.bind (Unify.sub (bod (Var nam dep)) (+ 1 dep) hol ctx) λbod
  (Maybe.pure (Let nam val λ_(bod)))))
(Unify.sub (Hol nam ctx None) dep hol ctx) =
  (If (Same nam hol) None (Maybe.pure (Hol nam ctx None)))
(Unify.sub (Hol nam ctx (Some val)) dep hol ctx) =
  (Maybe.bind (Unify.sub val dep hol ctx) λval
  (Maybe.pure (Hol nam ctx val)))
(Unify.sub Set dep hol ctx) =
  (Maybe.pure Set)
(Unify.sub U60 dep hol ctx) =
  (Maybe.pure U60)
(Unify.sub (Num val) dep hol ctx) =
  (Maybe.pure (Num val))
(Unify.sub (Op2 opr fst snd) dep hol ctx) =
  (Maybe.bind (Unify.sub fst dep hol ctx) λfst
  (Maybe.bind (Unify.sub snd dep hol ctx) λsnd
  (Maybe.pure (Op2 opr fst snd))))
(Unify.sub (Mat nam x z s p) dep hol ctx) =
  (Maybe.bind (Unify.sub x dep hol ctx) λx
  (Maybe.bind (Unify.sub z dep hol ctx) λz
  (Maybe.bind (Unify.sub (s (Var (String.concat nam "-1") dep)) dep hol ctx) λs
  (Maybe.bind (Unify.sub (p (Var nam dep)) dep hol ctx) λp
  (Maybe.pure (Mat nam x z λ_(s) λ_(p)))))))
(Unify.sub (Txt val) dep hol ctx) =
  (Maybe.pure (Txt val))
(Unify.sub (Var nam idx) dep hol ctx) =
  (Maybe.bind (Map.get λaλb(== a b) idx ctx) λval
  (Maybe.pure val))
(Unify.sub (Src src val) dep hol ctx) =
  (Maybe.bind (Unify.sub val dep hol ctx) λval
  (Maybe.pure (Src src val)))
(Unify.sub term dep hol ctx) =
  (HVM.log (UNEXPECTED (Show term dep)) None)

// TODO: use this
// Unify.rec : Fill -> Term -> String -> Bool
//(Unify.rec fill (All nam inp bod) hol) = (| (Unify.rec fill inp hol) (Unify.rec fill (bod Set) hol))
//(Unify.rec fill (Lam nam bod)     hol) = (Unify.rec fill (bod Set) hol)
//(Unify.rec fill (App fun arg)     hol) = (| (Unify.rec fill fun hol) (Unify.rec fill arg hol))
//(Unify.rec fill (Ann val typ)     hol) = (| (Unify.rec fill val hol) (Unify.rec fill typ hol))
//(Unify.rec fill (Slf nam typ bod) hol) = (Unify.rec fill typ hol)
//(Unify.rec fill (Ins val)         hol) = (Unify.rec fill val hol)
//(Unify.rec fill (Ref nam sub val) hol) = 0
//(Unify.rec fill (Let nam val bod) hol) = (| (Unify.rec fill val hol) (Unify.rec fill (bod Set) hol))
//(Unify.rec fill Set               hol) = 0
//(Unify.rec fill U60               hol) = 0
//(Unify.rec fill (Num val)         hol) = 0
//(Unify.rec fill (Op2 opr fst snd) hol) = (| (Unify.rec fill fst hol) (Unify.rec fill snd hol))
//(Unify.rec fill (Mat nam x z s p) hol) = (| (Unify.rec fill x hol) (| (Unify.rec fill z hol) (| (Unify.rec fill (s Set) hol) (Unify.rec fill (p Set) hol))))
//(Unify.rec fill (Txt val)         hol) = 0
//(Unify.rec fill (Var nam idx)     hol) = 0
//(Unify.rec fill (Src src val)     hol) = (Unify.rec fill val hol)
//(Unify.rec fill (Hol nam ctx)     hol) = (If (Same nam hol) 1 (Maybe.match (Map.get λaλb(Same a b) nam fill) λgot(Unify.rec fill got hol) 0))

// Type-Checking
// -------------

(IfAll (All nam inp bod) yep nop) = (yep nam inp bod)
(IfAll other             yep nop) = nop

(IfSlf (Slf nam typ bod) yep nop) = (yep nam typ bod)
(IfSlf other             yep nop) = nop

//(Infer term dep) = (Print dep ["Infer: " (Show term dep)] (Infer.match term dep))
(Infer term dep) = (Infer.match term dep)

(Infer.match (All nam inp bod) dep) =
  (Checker.bind (Check 0 inp Set dep) λinp_typ
  (Checker.bind (Check 0 (bod (Ann (Var nam dep) inp)) Set (+ 1 dep)) λbod_typ
  (Checker.pure Set)))
(Infer.match (App fun arg) dep) =
  (Checker.bind (Infer fun dep) λfun_typ
  ((IfAll (Reduce 1 fun_typ)
    λfun_nam λfun_typ.inp λfun_typ.bod λfun λarg
      (Checker.bind (Check 0 arg fun_typ.inp dep) λvty
      (Checker.pure (fun_typ.bod arg)))
    λfun λarg
      (Checker.fail (NonFunApp (App fun arg) dep)))
    fun arg))
(Infer.match (Ann val typ) dep) =
  (Checker.pure typ)
(Infer.match (Slf nam typ bod) dep) =
  (Checker.bind (Check 0 (bod (Ann (Var nam dep) typ)) Set (+ dep 1)) λslf
  (Checker.pure Set))
(Infer.match (Ins val) dep) =
  (Checker.bind (Infer val dep) λvty
  ((IfSlf (Reduce 1 vty)
    λvty.nam λvty.typ λvty.bod λval
      (Checker.pure (vty.bod (Ins val)))
    λval
      (Checker.fail (NonSlfIns (Ins val))))
    val))
(Infer.match (Ref nam sub val) dep) = 
  (Infer val dep)
(Infer.match Set dep) =
  (Checker.pure Set)
(Infer.match U60 dep) =
  (Checker.pure Set)
(Infer.match (Num num) dep) =
  (Checker.pure U60)
(Infer.match (Txt txt) dep) =
  (Checker.pure Book.String)
(Infer.match (Op2 opr fst snd) dep) =
  (Checker.bind (Check 0 fst U60 dep) λfst
  (Checker.bind (Check 0 snd U60 dep) λsnd
  (Checker.pure U60)))
(Infer.match (Mat nam x z s p) dep) =
  (Checker.bind (Check 0 x U60 dep) λx_typ
  (Checker.bind (Check 0 (p (Ann (Var nam dep) U60)) Set dep) λp_typ
  (Checker.bind (Check 0 z (p (Num 0)) dep) λz_typ
  (Checker.bind (Check 0 (s (Ann (Var (String.concat nam "-1") dep) U60)) (p (Op2 ADD (Num 1) (Var (String.concat nam "-1") dep))) (+ dep 1)) λs_typ
  (Checker.pure (p x))))))
(Infer.match (Lam nam bod) dep) =
  (Checker.fail (CantInfer (Lam nam bod) dep))
(Infer.match (Let nam val bod) dep) =
  (Checker.fail (CantInfer (Let nam val bod) dep))
(Infer.match (Hol nam ctx (Some val)) dep) =
  (Infer.match val dep)
(Infer.match (Hol nam ctx None) dep) =
  (Checker.fail (CantInfer (Hol nam ctx None) dep))
(Infer.match (Var nam idx) dep) =
  (Checker.fail (CantInfer (Var nam idx) dep))
(Infer.match (Src src val) dep) =
  (Infer.match val dep)

//(Check src term type dep) = (Print dep ["Check: " (Show term dep) " :: " (Show type dep) " ~> " (Show (Reduce 1 type) dep)] (Check.match src term type dep))
(Check src term type dep) = (Check.match src term type dep)

(Check.match src (Lam term.nam term.bod) type dep) =
  ((IfAll (Reduce 1 type)
    λtype.nam λtype.inp λtype.bod λterm.bod
      let ann  = (Ann (Var term.nam dep) type.inp)
      let term = (term.bod ann)
      let type = (type.bod ann)
      (Check 0 term type (+ dep 1))
    λterm.bod
      (Infer (Lam term.nam term.bod) dep))
    term.bod)
(Check.match src (Ins term.val) type dep) =
  ((IfSlf (Reduce 1 type)
    λtype.nam λtype.typ λtype.bod λterm.val
      (Check 0 term.val (type.bod (Ins term.val)) dep)
    λterm.val
      (Infer (Ins term.val) dep))
    term.val)
(Check.match src (Let term.nam term.val term.bod) type dep) =
  (Check 0 (term.bod term.val) type (+ 1 dep))
(Check.match src (Hol term.nam term.ctx (Some term.val)) type dep) =
  (Check src term.val type dep)
(Check.match src (Hol term.nam term.ctx None) type dep) =
  (Checker.bind (Checker.log (FoundHole term.nam type term.ctx dep)) λx
  (Checker.pure 0))
(Check.match src (Ref term.nam term.sub (Ann term.val term.typ)) type dep) = // better printing
  (Checker.bind (Equal type term.typ dep) λequal
  (Check.report src equal term.typ type (Ref term.nam term.sub term.val) dep))
(Check.match src (Src term.src term.val) type dep) =
  (Check term.src term.val type dep)
//(Check.match src (Ref term.nam term.val) type dep) =
  //(Check term.val type dep)
(Check.match src term type dep) =
  (Check.verify src term type dep)

(Check.verify src term type dep) =
  (Checker.bind (Infer term dep) λinfer
  (Checker.bind (Equal type infer dep) λequal
  (Check.report src equal infer type term dep)))

(Check.report src 0 detected expected value dep) =
  (Checker.fail (TypeMismatch src detected expected value dep))
(Check.report src n detected expected value dep) =
  (Checker.pure 0)

// Syntax
// ------

(Show (All nam inp bod) dep) = (String.join ["∀(" nam ": " (Show inp dep) ") " (Show (bod (Var nam dep)) (+ dep 1))])
(Show (Lam nam bod)     dep) = (String.join ["λ" nam " " (Show (bod (Var nam dep)) (+ dep 1))])
(Show (App fun arg)     dep) = (String.join ["(" (Show.unwrap (Show fun dep)) " " (Show arg dep) ")"])
(Show (Ann val typ)     dep) = (String.join ["{" (Show val dep) ": " (Show typ dep) "}"])
(Show (Slf nam typ bod) dep) = (String.join ["$(" nam ": " (Show typ dep) ") " (Show (bod (Var nam dep)) (+ dep 1))])
(Show (Ins val)         dep) = (String.join ["~" (Show val dep)])
(Show (Ref nam sub val) dep) = nam
(Show (Let nam val bod) dep) = (String.join ["let " nam " = " (Show val dep) "; " (Show (bod (Var nam dep)) (+ dep 1))])
(Show Set               dep) = (String.join ["*"])
(Show U60               dep) = "#U60"
(Show (Num val)         dep) = (String.join ["#" (U60.show val)])
(Show (Op2 opr fst snd) dep) = (String.join ["#(" (Op2.show opr) " " (Show fst dep) " " (Show snd dep) ")"])
(Show (Mat nam x z s p) dep) = (String.join ["#match " nam " = " (Show x dep) " { #0: " (Show z dep) " #+: " (Show (s (Var (String.concat nam "-1") dep)) (+ dep 1)) " }: " (Show (p (Var nam dep)) dep)])
(Show (Txt txt)         dep) = (String.join [Quote txt Quote])
(Show (Hol nam ctx val) dep) = (String.join ["?" nam "[" (Maybe.match val λx(Show x 0) "") "]"])
(Show (Var nam idx)     dep) = (String.join [nam])
(Show (Src src val)     dep) = (Show val dep)
//(Show (Src src val)     dep) = (String.join ["!" (Show val dep)])
//(Show (Var nam idx)     dep) = (String.join [nam "'" (U60.show idx)])

(Show.many List.nil         dep) = ""
(Show.many (List.cons x xs) dep) = (String.join [" " (Show x dep) (Show.many xs dep)])

(Show.trim (String.cons ' ' xs)) = xs
(Show.trim str)                  = str

(Show.unwrap (String.cons '(' xs)) = (Show.begin xs)
(Show.unwrap str)                  = str

(Show.begin (String.cons x (String.cons y String.nil))) = (String.cons x String.nil)
(Show.begin (String.cons x xs))                         = (String.cons x (Show.begin xs))
(Show.begin String.nil)                                 = String.nil

(Op2.show ADD) = "+"
(Op2.show SUB) = "-"
(Op2.show MUL) = "*"
(Op2.show DIV) = "/"
(Op2.show MOD) = "%"
(Op2.show EQ)  = "=="
(Op2.show NE)  = "!="
(Op2.show LT)  = "<"
(Op2.show GT)  = ">"
(Op2.show LTE) = "<="
(Op2.show GTE) = ">="
(Op2.show AND) = "&"
(Op2.show OR)  = "|"
(Op2.show XOR) = "^"
(Op2.show LSH) = "<<"
(Op2.show RSH) = ">>"

(Context.show List.nil         dep) = ""
(Context.show (List.cons x xs) dep) = (String.join [NewLine "- " (Context.show.ann x dep) (Context.show xs dep)])

(Context.show.ann (Ann val typ) dep) = (String.join ["{" (Show (Normal 0 val dep) dep) ": " (Show (Normal 0 typ dep) dep) "}"])
(Context.show.ann term          dep) = (Show (Normal 0 term dep) dep)
//(Context.show.ann val           dep) = (String.join ["{" (Show (Normal 0 val dep) dep) ": " (Show (Normal 0 (Infer val dep) dep) dep) "}"])

(Message.show (FoundHole name type ctx dep)) =
  let bold  = (String.color BRIGHT)
  let reset = (String.color RESET)
  let type  = (Show (Normal 0 type dep) dep)
  let ctx   = (Context.show ctx dep)
  (String.join [bold "HOLE:" reset " ?" name " :: " type ctx])
(Message.show (NonFunApp term dep)) =
  let term = (Show term dep)
  (String.join ["NON_FUNCTION: " term])
(Message.show (CantInfer term dep)) =
  let term = (Show term dep)
  (String.join ["CANT_INFER: " term])
(Message.show (TypeMismatch src detected expected value dep)) =
  let det = (Show (Normal 0 detected dep) dep)
  let exp = (Show (Normal 0 expected dep) dep)
  let val = (Show (Normal 0 value dep) dep)
  (String.join [(String.color BRIGHT) "TYPE_MISMATCH" NewLine
    "- expected: " (String.color RESET) (String.color GREEN) exp NewLine (String.color RESET) (String.color BRIGHT)
    "- detected: " (String.color RESET) (String.color RED)   det NewLine (String.color RESET) (String.color BRIGHT)
    "- bad_term: " (String.color RESET) (String.color DIM)   val NewLine (String.color RESET)
    "##LOC{" (U60.show src) "}LOC##" NewLine
  ])
(Message.show (Fill hole value dep)) =
  let val = (Show (Normal 0 value dep) dep)
  (String.join ["FILL: ?" hole " = " val])

// Compilation
// -----------

(Str.view str) = (str 0 λheadλtail(String.cons head (Str.view tail)) String.nil)

(Str.make (String.cons x xs)) = λP λcons λnil (cons x (Str.make xs))
(Str.make String.nil)         = λP λcons λnil nil

Compile.primitives = [
  (Pair "HVM.log" λA λB λmsg λret (HVM.log msg ret))
  (Pair "HVM.print" λA λmsg λret (HVM.print (Str.view msg) ret))
  (Pair "HVM.save" λA λname λdata λret (HVM.save (Str.view name) (Str.view data) ret))
  (Pair "HVM.load" λA λname λret (HVM.load (Str.view name) λdata (ret (Str.make data))))
]

(Compile (All nam inp bod)) = 0
(Compile (Lam nam bod))     = λx(Compile (bod (Var "" x)))
(Compile (App fun arg))     = ((Compile fun) (Compile arg))
(Compile (Ann val typ))     = (Compile val)
(Compile (Slf nam typ bod)) = 0
(Compile (Ins val))         = (Compile val)
(Compile (Ref nam sub val)) = (Compile.ref Compile.primitives nam val)
(Compile (Let nam val bod)) = (Compile (bod val))
(Compile Set)               = 0
(Compile U60)               = 0
(Compile (Num val))         = val
(Compile (Op2 opr fst snd)) = (Compile.op2 opr (Compile fst) (Compile snd))
(Compile (Mat nam x z s p)) = (Compile.mat (Compile x) (Compile z) λx(Compile (s (Var "" x))))
(Compile (Txt txt))         = (Str.make txt)
(Compile (Hol nam ctx val)) = 0
(Compile (Var nam val))     = val
(Compile (Src src val))     = (Compile val)

//(Compile.txt (String.cons x xs)) = (App (App Book.String.cons (Num x)) (Compile.txt xs))
//(Compile.txt String.nil)         = Book.String.nil

(Compile.op2 ADD fst snd) = (+ fst snd)
(Compile.op2 SUB fst snd) = (- fst snd)
(Compile.op2 MUL fst snd) = (* fst snd)
(Compile.op2 DIV fst snd) = (/ fst snd)
(Compile.op2 MOD fst snd) = (% fst snd)
(Compile.op2 EQ  fst snd) = (== fst snd)
(Compile.op2 NE  fst snd) = (!= fst snd)
(Compile.op2 LT  fst snd) = (< fst snd)
(Compile.op2 GT  fst snd) = (> fst snd)
(Compile.op2 LTE fst snd) = (<= fst snd)
(Compile.op2 GTE fst snd) = (>= fst snd)
(Compile.op2 AND fst snd) = (& fst snd)
(Compile.op2 OR  fst snd) = (| fst snd)
(Compile.op2 XOR fst snd) = (^ fst snd)
(Compile.op2 LSH fst snd) = (<< fst snd)
(Compile.op2 RSH fst snd) = (>> fst snd)

(Compile.mat 0 z s) = z
(Compile.mat n z s) = (s (- n 1))

(Compile.ref (List.cons (Pair prim_name prim_func) prims) nam val) = (If (Same prim_name nam) prim_func (Compile.ref prims nam val))
(Compile.ref List.nil nam val) = (Compile val)

// API
// ---

// Normalizes a definition.
(API.normal (Ref nam sub val)) =
  (Compile (Subst sub val))

// Checks a definition.
(API.check (Ref nam sub def)) =
  //(HVM.print (String.join ["Running: " (Show (Subst sub def) 0)])
  let done = λlogs λvalue
    ((API.check.log logs)
    (Pair.get (API.check.fill sub logs) λfilled λsub
    let true  = (HVM.print "Solving..." (API.check (Ref nam sub def)))
    let false = (HVM.print "Done!" 1)
    (If filled true false)))
  let fail = λlogs λerror
    ((API.check.log logs)
    ((API.check.log [error]) 0))
  (Result.match (Checker.run (API.check.do (Subst sub def))) done fail)

// Calls check on typed defs and infer on untyped defs.
(API.check.do (Ann val typ)) = (Check 0 val typ 0)
(API.check.do val)           = (Infer val 0)

// Moves solutions from the checker logs to a ref's subst list.
(API.check.fill sub (List.cons (Fill k v d) xs)) = (Pair.get (API.check.fill sub xs) λokλmap(Pair 1 (Map.set λxλy(Same x y) k (Some v) sub)))
//(API.check.fill sub (List.cons (Fill k v d) xs)) = (Pair.get (API.check.fill sub xs) λokλmap(Pair 1 (HVM.log (FILL k (Show v 0)) sub)))
(API.check.fill sub (List.cons message xs))      = (API.check.fill sub xs)
(API.check.fill sub List.nil)                    = (Pair 0 sub)


(API.check.log (List.cons msg msgs)) = (HVM.print (Message.show msg) (API.check.log msgs))
(API.check.log List.nil)             = λx x

Book.Bool = (Ref "Bool" [] (Ann (Src 2199034789997 (Slf "self" (Src 2199043178519 (Book.Bool)) λ_self (Src 2199051567213 (All "P" (Src 2199058907184 (All "x" (Src 2199066247213 (Book.Bool)) λ_x (Src 2199072538672 (Set)))) λ_P (Src 2199077781613 (All "t" (Src 2199085121608 (App (Src 2199086170173 _P) (Src 2199088267335 (Book.Bool.true)))) λ_t (Src 2199102947437 (All "f" (Src 2199110287457 (App (Src 2199111336021 _P) (Src 2199113433184 (Book.Bool.false)))) λ_f (Src 2199129161837 (App (Src 2199130210407 _P) (Src 2199132307564 _self))))))))))) (Src 2199030595592 (Set))))
Book.Bool.false = (Ref "Bool.false" [] (Ann (Src 3298555854882 (Ins (Src 3298556903458 (Lam "P" λ_P (Src 3298561097762 (Lam "t" λ_t (Src 3298565292066 (Lam "f" λ_f (Src 3298569486370 _f))))))))) (Src 3298548514833 (Book.Bool))))
Book.Bool.true = (Ref "Bool.true" [] (Ann (Src 4398066434081 (Ins (Src 4398067482657 (Lam "P" λ_P (Src 4398071676961 (Lam "t" λ_t (Src 4398075871265 (Lam "f" λ_f (Src 4398080065569 _t))))))))) (Src 4398059094032 (Book.Bool))))
Book.Char = (Ref "Char" [] (Ann (Src 9895616184335 (U60)) (Src 9895611990024 (Set))))
Book.List = (Ref "List" [] (Ann (Src 10995140395198 (Lam "T" λ_T (Src 10995146686654 (Slf "self" (Src 10995155075117 (App (Src 10995156123690 (Book.List)) (Src 10995161366572 _T))) λ_self (Src 10995167658174 (All "P" (Src 10995174998091 (All "xs" (Src 10995183386696 (App (Src 10995184435269 (Book.List)) (Src 10995189678151 _T))) λ_xs (Src 10995193872459 (Set)))) λ_P (Src 10995199115454 (All "cons" (Src 10995209601173 (All "head" (Src 10995220086884 _T) λ_head (Src 10995223232661 (All "tail" (Src 10995233718392 (App (Src 10995234766965 (Book.List)) (Src 10995240009847 _T))) λ_tail (Src 10995244204181 (App (Src 10995245252732 _P) (Src 10995247349908 (App (App (App (Src 10995248398471 (Book.List.cons)) (Src 10995258884233 _T)) (Src 10995260981390 _head)) (Src 10995266224275 _tail))))))))) λ_cons (Src 10995276710078 (All "nil" (Src 10995286147250 (App (Src 10995287195812 _P) (Src 10995289292977 (App (Src 10995290341550 (Book.List.nil)) (Src 10995299778736 _T))))) λ_nil (Src 10995307118782 (App (Src 10995308167352 _P) (Src 10995310264509 _self))))))))))))) (Src 10995123617812 (All "T" (Src 10995130957839 (Set)) λ_T (Src 10995136200724 (Set))))))
Book.List.cons = (Ref "List.cons" [] (Ann (Src 12094703403136 (Lam "T" λ_T (Src 12094707597440 (Lam "head" λ_head (Src 12094714937472 (Lam "tail" λ_tail (Src 12094724374656 (Ins (Src 12094725423232 (Lam "P" λ_P (Src 12094729617536 (Lam "cons" λ_cons (Src 12094736957568 (Lam "nil" λ_nil (Src 12094745346176 (App (App (Src 12094746394741 _cons) (Src 12094751637626 _head)) (Src 12094756880511 _tail))))))))))))))))) (Src 12094640488517 (All "T" (Src 12094647828500 (Set)) λ_T (Src 12094653071429 (All "head" (Src 12094663557155 _T) λ_head (Src 12094668800069 (All "tail" (Src 12094679285817 (App (Src 12094680334390 (Book.List)) (Src 12094685577272 _T))) λ_tail (Src 12094691868741 (App (Src 12094692917314 (Book.List)) (Src 12094698160196 _T)))))))))))
Book.List.nil = (Ref "List.nil" [] (Ann (Src 13194175184959 (Lam "T" λ_T (Src 13194181476415 (Ins (Src 13194182524991 (Lam "P" λ_P (Src 13194186719295 (Lam "cons" λ_cons (Src 13194194059327 (Lam "nil" λ_nil (Src 13194202447935 _nil))))))))))) (Src 13194151067679 (All "T" (Src 13194158407699 (Set)) λ_T (Src 13194163650591 (App (Src 13194164699164 (Book.List)) (Src 13194169942046 _T)))))))
Book.Main = (Ref "Main" [(Pair "A" None)]  λh_A(Ann (Src 1099558813767 (Lam "b" λ_b (Src 1099563008071 (App (App (App (Src 1099564056628 (Ins (Src 1099565105204 _b))) (Src 1099567202359 (Hol "A" [_b] h_A))) (Src 1099570348096 (Book.Nat.zero))) (Src 1099579785286 (Txt "foo")))))) (Src 1099518967850 (All "b" (Src 1099526307858 (Book.Bool)) λ_b (Src 1099532599338 (App (App (App (Src 1099533647895 (Ins (Src 1099534696471 _b))) (Src 1099536793630 (Lam "x" λ_x (Src 1099539939358 (Src 1099540987933 (Set)))))) (Src 1099544133666 (Book.Nat))) (Src 1099548327977 (Book.String))))))))
Book.Nat = (Ref "Nat" [] (Ann (Src 5497568624765 (Slf "self" (Src 5497577013269 (Book.Nat)) λ_self (Src 5497584353405 (All "P" (Src 5497591693357 (All "n" (Src 5497599033386 (Book.Nat)) λ_n (Src 5497604276269 (Set)))) λ_P (Src 5497609519229 (All "succ" (Src 5497620004951 (All "n" (Src 5497627344965 (Book.Nat)) λ_n (Src 5497632587863 (App (Src 5497633636425 _P) (Src 5497635733590 (App (Src 5497636782163 (Book.Nat.succ)) (Src 5497646219349 _n))))))) λ_succ (Src 5497653559421 (All "zero" (Src 5497664045169 (App (Src 5497665093735 _P) (Src 5497667190896 (Book.Nat.zero)))) λ_zero (Src 5497680822397 (App (Src 5497681870967 _P) (Src 5497683968124 _self))))))))))) (Src 5497564430343 (Set))))
Book.Nat.succ = (Ref "Nat.succ" [] (Ann (Src 6597100175424 (Lam "n" λ_n (Src 6597106466880 (Ins (Src 6597107515456 (Lam "P" λ_P (Src 6597111709760 (Lam "succ" λ_succ (Src 6597119049792 (Lam "zero" λ_zero (Src 6597128486976 (App (Src 6597129535549 _succ) (Src 6597134778431 _n))))))))))))) (Src 6597081301018 (All "n" (Src 6597088641045 (Book.Nat)) λ_n (Src 6597093883930 (Book.Nat))))))
Book.Nat.zero = (Ref "Nat.zero" [] (Ann (Src 7696599220266 (Ins (Src 7696600268842 (Lam "P" λ_P (Src 7696604463146 (Lam "succ" λ_succ (Src 7696611803178 (Lam "zero" λ_zero (Src 7696621240362 _zero))))))))) (Src 7696592928782 (Book.Nat))))
Book.String = (Ref "String" [] (Ann (Src 8796106653720 (App (Src 8796107702290 (Book.List)) (Src 8796112945175 (Book.Char)))) (Src 8796102459402 (Set))))
Book.String.cons = (Ref "String.cons" [] (Ann (Src 14293715124337 (Lam "head" λ_head (Src 14293722464369 (Lam "tail" λ_tail (Src 14293731901553 (Ins (Src 14293732950129 (Lam "P" λ_P (Src 14293737144433 (Lam "cons" λ_cons (Src 14293744484465 (Lam "nil" λ_nil (Src 14293752873073 (App (App (Src 14293753921638 _cons) (Src 14293759164523 _head)) (Src 14293764407408 _tail))))))))))))))) (Src 14293665841210 (All "head" (Src 14293676326940 (Book.Char)) λ_head (Src 14293684715578 (All "tail" (Src 14293695201328 (Book.String)) λ_tail (Src 14293705687098 (Book.String))))))))
Book.String.nil = (Ref "String.nil" [] (Ann (Src 15393185857581 (Ins (Src 15393186906157 (Lam "P" λ_P (Src 15393191100461 (Lam "cons" λ_cons (Src 15393198440493 (Lam "nil" λ_nil (Src 15393206829101 _nil))))))))) (Src 15393176420371 (Book.String))))

Main = (API.check Book.Main)
